-- GameManager (Часть 2.1 - Исправленная версия с циклом игры)
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- НАСТРОЙКИ
local COUNTDOWN_SECONDS = 10
local ROUND_DURATION = 300 -- 5 минут

-- ССЫЛКИ НА ОБЪЕКТЫ
local startGamePlatform = Workspace:WaitForChild("StartGame")
local buildZones = Workspace:WaitForChild("BuildZones"):GetChildren()
local UpdateCountdownUI = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("UpdateCountdownUI")
local UpdateGameUIEvent = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("UpdateGameUIEvent")
local BrickSets = ReplicatedStorage:WaitForChild("BrickSets")
local CurrentBrickSet = BrickSets:WaitForChild("LegoHouseSet")
local CurrentTemplateSet = BrickSets:WaitForChild("LegoHouseSet_Template")

-- ПЕРЕМЕННЫЕ СОСТОЯНИЯ
local playersInLobby = {}
local countdownInProgress = false
local gameInProgress = false
local playerProgress = {}

-- <<-- НОВАЯ ФУНКЦИЯ ОЧИСТКИ -->>
-- Она будет удалять все, что мы создали для раунда
local function cleanupMap()
    for _, child in ipairs(Workspace:GetChildren()) do
        if child:GetAttribute("IsGameAsset") then
            child:Destroy()
        end
    end
end

-- Функция телепортации и ПОДГОТОВКИ к игре
local function setupGame(playersToPlay)
    print("Начинаем игру для " .. #playersToPlay .. " игроков!")
    gameInProgress = true
    playerProgress = {}   
    
    local availableBuildZones = {}
    for i=1, #buildZones do table.insert(availableBuildZones, buildZones[i]) end

    for _, player in ipairs(playersToPlay) do
        if player.Character then
            local randomIndex = math.random(1, #availableBuildZones)
            local buildZone = table.remove(availableBuildZones, randomIndex)
            if buildZone then
                player.Character:SetPrimaryPartCFrame(buildZone.CFrame + Vector3.new(0, 5, 0))
                
                local template = CurrentTemplateSet:Clone()
                template.Name = "Template_" .. player.Name
                template:SetPrimaryPartCFrame(buildZone.CFrame + Vector3.new(0, 10, 0))
                template:SetAttribute("IsGameAsset", true)
                template.Parent = Workspace
                
                local partSet = CurrentBrickSet:Clone()
                partSet.Name = "PartSet_" .. player.Name
                partSet:SetPrimaryPartCFrame(buildZone.CFrame + Vector3.new(15, 2, 0))
                partSet:SetAttribute("IsGameAsset", true)
                partSet.Parent = Workspace

                playerProgress[player.UserId] = {
                    placedBricks = {},
                    finished = false,
                    timeTaken = 0,
                    roundTimer = ROUND_DURATION
                }
            end
        end
    end

    -- Запускаем таймер раунда
    for i = ROUND_DURATION, 0, -1 do
        local minutes = math.floor(i / 60)
        local seconds = i % 60
        local timerText = string.format("%02d:%02d", minutes, seconds)
        UpdateGameUIEvent:FireAllClients("UpdateTimer", "Раунд: " .. timerText)

        for userId, progressData in pairs(playerProgress) do
            if not progressData.finished then
                progressData.roundTimer = i
            end
        end
        wait(1)
    end
    
    -- <<-- НОВЫЙ БЛОК: ЗАВЕРШЕНИЕ РАУНДА -->>
    print("Раунд окончен!")
    UpdateGameUIEvent:FireAllClients("UpdateTimer", "Раунд окончен!") -- Сообщаем игрокам
    
    -- 1. Очищаем карту от деталей и шаблонов
    cleanupMap()
    
    -- 2. Телепортируем всех обратно в лобби
    for _, player in ipairs(playersToPlay) do
        if player.Character then
            -- Телепортируем на случайную точку на платформе
            local randomOffset = Vector3.new(math.random(-5, 5), 5, math.random(-5, 5))
            player.Character:SetPrimaryPartCFrame(startGamePlatform.CFrame + randomOffset)
        end
    end

    -- 3. Сообщаем скрипту, что игра окончена и можно начинать новый поиск в лобби
    gameInProgress = false
end

-- Функция отсчета в лобби (без изменений)
local function startLobbyCountdown()
    countdownInProgress = true
    for i = COUNTDOWN_SECONDS, 1, -1 do
        if #playersInLobby == 0 then
            UpdateCountdownUI:FireAllClients(false)
            countdownInProgress = false
            return
        end
        UpdateCountdownUI:FireAllClients(i)
        wait(1)
    end
    
    UpdateCountdownUI:FireAllClients(false)
    
    local playersToStart = {}
    for _, p in ipairs(playersInLobby) do table.insert(playersToStart, p) end
    
    -- Запускаем игру в отдельном потоке, чтобы не блокировать цикл лобби
    coroutine.wrap(setupGame)(playersToStart)
    countdownInProgress = false
end

-- Главный цикл проверки лобби (без изменений)
while true do
    wait(0.5)
    if not gameInProgress then
        local playersFound = {}
        local touchingParts = Workspace:GetPartsInPart(startGamePlatform)
        for _, part in ipairs(touchingParts) do
            local player = Players:GetPlayerFromCharacter(part.Parent)
            if player and not table.find(playersFound, player) then
                table.insert(playersFound, player)
            end
        end
        playersInLobby = playersFound
        
        if #playersInLobby > 0 and not countdownInProgress then
            coroutine.wrap(startLobbyCountdown)()
        end
    end
end
