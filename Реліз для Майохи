import pygame
from random import randint, choice

pygame.init()

WIDTH, HEIGHT = 600, 800
screen = pygame.display.set_mode((WIDTH, HEIGHT))
background = pygame.image.load("BackgroundMINER.png")
background = pygame.transform.scale(background, (WIDTH, HEIGHT))
clock = pygame.time.Clock()
pygame.display.set_caption("MinerLVL")

# Типы блоков и их файлы изображений
BLOCK_TYPES = [
    "Iron_block.png",
    "Stone_Block.png",
    "Diamond_Block.png",
    "Dirt_Block.png"
]

# Класс для платформ (блоков)
class Platform(pygame.sprite.Sprite):
    def __init__(self, x, y, width, height, filename):
        super().__init__()
        self.image = pygame.image.load(filename)
        self.image = pygame.transform.scale(self.image, (width, height))
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
    
    def draw(self):
        screen.blit(self.image, self.rect)

# Класс для кирки (игрового объекта)
class GameObject(pygame.sprite.Sprite):
    def __init__(self, filename, x=0, y=0, width=10, height=10):
        super().__init__()
        self.image_right = pygame.image.load(filename)
        self.image_right = pygame.transform.scale(self.image_right, (width, height))
        self.image_left = pygame.transform.flip(self.image_right, True, False)
        self.image = self.image_right
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.facing_right = True
        self.velocity_y = 0 # Вертикальная скорость

    def draw(self):
        screen.blit(self.image, self.rect)

    def apply_gravity(self):
        self.velocity_y += GRAVITY
        self.rect.y += self.velocity_y
        
        # Если кирка ушла слишком далеко вниз (на случай, если нет блоков), сбрасываем её
        if self.rect.top > HEIGHT:
            self.reset_position()

    def reset_position(self):
        # Сброс кирки в случайное X вверху экрана
        self.rect.x = randint(0, WIDTH - self.rect.width)
        self.rect.y = 0
        self.velocity_y = 0

# Параметры игры
GRAVITY = 1.0 # Сила гравитации
BLOCK_SIZE = 100 # Размер блоков (предполагаем 100x100)
VISIBLE_ROWS_OF_BLOCKS = 4 # Количество видимых рядов блоков на экране

player = GameObject("Wooden_Pickaxe.png", randint(0, WIDTH - 75), 0, 75, 75)

# Создаем группу спрайтов для платформ для удобства
all_platforms = pygame.sprite.Group()

def generate_row_at_y(y_position):
    """Генерирует новый ряд случайных блоков на заданной Y-позиции."""
    for i in range(WIDTH // BLOCK_SIZE):
        block_filename = choice(BLOCK_TYPES)
        new_block = Platform(i * BLOCK_SIZE, y_position, BLOCK_SIZE, BLOCK_SIZE, block_filename)
        all_platforms.add(new_block)

def initial_block_generation():
    """Генерирует начальные ряды блоков, заполняя нижнюю часть экрана."""
    for row in range(VISIBLE_ROWS_OF_BLOCKS):
        # Размещаем блоки снизу вверх
        y_pos = HEIGHT - (VISIBLE_ROWS_OF_BLOCKS - row) * BLOCK_SIZE
        generate_row_at_y(y_pos)

initial_block_generation()

# Игровой цикл
start = True
while start:
    screen.blit(background, (0,0))
    
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            start = False
        
    # Применяем гравитацию к кирке
    player.apply_gravity()

    # Проверяем столкновения между киркой и платформами
    # 'True' в spritecollide означает, что столкнувшиеся блоки будут удалены из группы
    collided_blocks = pygame.sprite.spritecollide(player, all_platforms, True) 
    
    # Если кирка столкнулась хотя бы с одним блоком
    if collided_blocks:
        player.reset_position() # Кирка возвращается наверх

        # Сдвигаем все оставшиеся блоки вверх
        for platform in all_platforms:
            platform.rect.y -= BLOCK_SIZE # Двигаем вверх на высоту одного блока
        
        # Удаляем блоки, которые ушли за верхнюю границу экрана
        for platform in all_platforms.copy(): # Используем .copy() для безопасного удаления из группы во время итерации
            if platform.rect.bottom < 0: # Если низ блока ушёл выше верхней границы экрана
                all_platforms.remove(platform)
        
        # Генерируем новый ряд блоков в самом низу (который при следующем сдвиге станет видимым)
        # Он должен быть на Y-позиции, которая будет чуть ниже текущего самого нижнего видимого блока,
        # чтобы он "подъехал" на место
        generate_row_at_y(HEIGHT - BLOCK_SIZE) # Новый ряд появляется прямо над нижней границей экрана

    # Отрисовываем все платформы и кирку
    all_platforms.draw(screen)
    player.draw()
    
    pygame.display.flip()
    clock.tick(60)

pygame.quit()
