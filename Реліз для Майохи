import pygame
from random import randint, choice

pygame.init()

# --- Параметры игры ---
WIDTH, HEIGHT = 600, 800
FPS = 60
GRAVITY = 1.0 # Сила гравитации

BLOCK_SIZE = 100 # Размер одного блока (квадрата)
# Количество рядов блоков, которые будут видны на экране
# Это будет поддерживаться постоянно
VISIBLE_ROWS = HEIGHT // BLOCK_SIZE 
if HEIGHT % BLOCK_SIZE != 0: # Если высота не делится нацело, добавляем 1 ряд, чтобы занять все пространство
    VISIBLE_ROWS += 1

# --- Загрузка ресурсов ---
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("MinerLVL")

try:
    background = pygame.image.load("BackgroundMINER.png").convert_alpha()
    background = pygame.transform.scale(background, (WIDTH, HEIGHT))
except pygame.error as e:
    print(f"Ошибка загрузки фона: {e}. Убедитесь, что файл 'BackgroundMINER.png' существует.")
    background = pygame.Surface((WIDTH, HEIGHT)) # Создаем пустую поверхность на случай ошибки
    background.fill((0, 0, 0)) # Заливаем черным

# Типы блоков и их файлы изображений
BLOCK_IMAGES = {
    "iron": pygame.transform.scale(pygame.image.load("Iron_block.png").convert_alpha(), (BLOCK_SIZE, BLOCK_SIZE)),
    "stone": pygame.transform.scale(pygame.image.load("Stone_Block.png").convert_alpha(), (BLOCK_SIZE, BLOCK_SIZE)),
    "diamond": pygame.transform.scale(pygame.image.load("Diamond_Block.png").convert_alpha(), (BLOCK_SIZE, BLOCK_SIZE)),
    "dirt": pygame.transform.scale(pygame.image.load("Dirt_Block.png").convert_alpha(), (BLOCK_SIZE, BLOCK_SIZE))
}
BLOCK_TYPES_LIST = list(BLOCK_IMAGES.keys()) # Список для случайного выбора типа блока

try:
    PICKAXE_IMAGE = pygame.transform.scale(pygame.image.load("Wooden_Pickaxe.png").convert_alpha(), (75, 75))
except pygame.error as e:
    print(f"Ошибка загрузки кирки: {e}. Убедитесь, что файл 'Wooden_Pickaxe.png' существует.")
    PICKAXE_IMAGE = pygame.Surface((75, 75)) # Заглушка
    PICKAXE_IMAGE.fill((255, 0, 0)) # Красный квадрат

# --- Класс для Блоков (Платформ) ---
class Block(pygame.sprite.Sprite):
    def __init__(self, x, y, block_type):
        super().__init__()
        self.type = block_type
        self.image = BLOCK_IMAGES[self.type]
        self.rect = self.image.get_rect(topleft=(x, y))

    def update(self):
        # Метод update можно использовать для дополнительной логики блока, если понадобится
        pass

# --- Класс для Кирки (Игрового Объекта) ---
class Pickaxe(pygame.sprite.Sprite):
    def __init__(self, image):
        super().__init__()
        self.image = image
        self.rect = self.image.get_rect()
        self.reset_position() # Устанавливаем начальную позицию

    def update(self):
        self.apply_gravity()

    def apply_gravity(self):
        self.velocity_y += GRAVITY
        self.rect.y += self.velocity_y
        
        # Если кирка ушла слишком далеко вниз (на случай, если нет блоков или баг), сбрасываем её
        if self.rect.top > HEIGHT:
            self.reset_position()

    def reset_position(self):
        # Сброс кирки в случайное X вверху экрана
        self.rect.x = randint(0, WIDTH - self.rect.width)
        self.rect.y = 0
        self.velocity_y = 0

# --- Функции генерации и управления блоками ---
all_blocks = pygame.sprite.Group() # Группа для всех блоков

def generate_row_of_blocks(y_position):
    """Генерирует новый ряд случайных блоков на заданной Y-позиции."""
    for i in range(WIDTH // BLOCK_SIZE):
        block_type = choice(BLOCK_TYPES_LIST)
        new_block = Block(i * BLOCK_SIZE, y_position, block_type)
        all_blocks.add(new_block)

def initialize_game_area():
    """Заполняет нижнюю часть экрана начальными рядами блоков."""
    # Создаем блоки, заполняя экран снизу вверх
    for row in range(VISIBLE_ROWS):
        y_pos = HEIGHT - (VISIBLE_ROWS - row) * BLOCK_SIZE
        generate_row_of_blocks(y_pos)

def shift_all_blocks_up():
    """Сдвигает все существующие блоки вверх на высоту одного блока."""
    for block in all_blocks:
        block.rect.y -= BLOCK_SIZE

def remove_offscreen_blocks():
    """Удаляет блоки, которые полностью ушли за верхнюю границу экрана."""
    for block in all_blocks.copy(): # Используем .copy() для безопасного удаления
        if block.rect.bottom < 0:
            all_blocks.remove(block)

# --- Инициализация игры ---
player = Pickaxe(PICKAXE_IMAGE)
initialize_game_area() # Генерируем начальные блоки

clock = pygame.time.Clock()
running = True

# --- Игровой цикл ---
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        
    # --- Обновление объектов ---
    player.update() # Обновляем позицию кирки (применяем гравитацию)

    # Проверяем столкновения между киркой и блоками
    # 'True' означает, что столкнувшиеся блоки будут удалены из группы 'all_blocks'
    collided_blocks = pygame.sprite.spritecollide(player, all_blocks, True) 
    
    # Если кирка столкнулась хотя бы с одним блоком
    if collided_blocks:
        player.reset_position() # Кирка возвращается наверх

        shift_all_blocks_up() # Сдвигаем все оставшиеся блоки вверх
        remove_offscreen_blocks() # Удаляем блоки, ушедшие за верх экрана
        
        # Генерируем НОВЫЙ ряд блоков в самом низу (который при следующем сдвиге поднимется)
        # Этот ряд должен появиться в нижней части экрана, чтобы заполнить "пустоту"
        generate_row_of_blocks(HEIGHT - BLOCK_SIZE) 

    # --- Отрисовка ---
    screen.blit(background, (0,0)) # Рисуем фон

    all_blocks.draw(screen) # Отрисовываем все блоки
    player.draw() # Отрисовываем кирку
    
    pygame.display.flip() # Обновляем весь экран
    clock.tick(FPS) # Контроль FPS

pygame.quit()
