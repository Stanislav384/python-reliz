import pygame
import os # Импортируем модуль os для работы с путями к файлам

pygame.init()
WIDTH, HEIGHT = 1280, 720
screen = pygame.display.set_mode((WIDTH, HEIGHT))
background = pygame.transform.scale(pygame.image.load("fon.jpg"), (WIDTH, HEIGHT))
clock = pygame.time.Clock()

GRAVITY = 1
JUMP_POWER = -20
GROUND_Y = 400 # Отрегулируйте это значение в зависимости от вашего фона и размера персонажа

class GameObject():
    def __init__(self, x=0, y=0, width=100, height=100):
        # Словари для хранения кадров анимации для разных состояний
        self.animations_right = {}
        self.animations_left = {}

        self.animation_speed = 0.15 # Регулируйте это значение для контроля скорости анимации
        self.current_frame_index = 0
        self.animation_counter = 0

        self.current_animation_set_right = [] # Текущий набор кадров для движения вправо
        self.current_animation_set_left = [] # Текущий набор кадров для движения влево

        # Загрузка всех анимаций
        self._load_animation_frames("player_idle", width, height)
        self._load_animation_frames("player_walk", width, height)
        self._load_animation_frames("player_jump", width, height)

        # Устанавливаем начальную анимацию (бездействие)
        self.set_animation_state("idle")

        # Если кадры были загружены, устанавливаем начальное изображение
        if self.current_animation_set_right:
            self.image = self.current_animation_set_right[self.current_frame_index]
        else:
            # Заглушка, если кадры не загружены
            print("Warning: No initial animation frames loaded.")
            self.image = pygame.Surface((width, height))
            self.image.fill((255, 0, 255)) # Маджента для отладки

        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.facing_right = True
        self.velocity_y = 0
        self.isJumping = False
        self.is_moving = False
        self.is_falling = False # Новый флаг для состояния падения

    def _load_animation_frames(self, folder_name, width, height):
        """Вспомогательная функция для загрузки кадров анимации из указанной папки."""
        right_frames = []
        left_frames = []
        path = os.path.join("data", folder_name)

        if not os.path.exists(path):
            print(f"Error: Animation folder '{path}' not found.")
            return

        # Получаем список файлов, сортируем их для правильного порядка
        image_files = sorted([f for f in os.listdir(path) if f.endswith(".png")])

        if not image_files:
            print(f"Warning: No image files found in '{path}'.")
            return

        for filename in image_files:
            try:
                img_path = os.path.join(path, filename)
                img_right = pygame.image.load(img_path).convert_alpha() # .convert_alpha() для прозрачности
                img_right = pygame.transform.scale(img_right, (width, height))
                right_frames.append(img_right)
                left_frames.append(pygame.transform.flip(img_right, True, False))
            except pygame.error as e:
                print(f"Error loading image {img_path}: {e}")

        self.animations_right[folder_name] = right_frames
        self.animations_left[folder_name] = left_frames

    def set_animation_state(self, state_name):
        """Устанавливает текущий набор анимационных кадров."""
        if state_name in self.animations_right and state_name in self.animations_left:
            self.current_animation_set_right = self.animations_right[state_name]
            self.current_animation_set_left = self.animations_left[state_name]
            self.current_frame_index = 0 # Сбрасываем индекс при смене анимации
            self.animation_counter = 0 # Сбрасываем счетчик
        else:
            print(f"Error: Animation state '{state_name}' not found.")
            # Fallback to idle if specified state is missing
            if "player_idle" in self.animations_right:
                self.current_animation_set_right = self.animations_right["player_idle"]
                self.current_animation_set_left = self.animations_left["player_idle"]
            else:
                self.current_animation_set_right = []
                self.current_animation_set_left = []


    def draw(self):
        # Рисуем объект на экране
        screen.blit(self.image, self.rect)

    def move(self, dx):
        # Двигаем объект по оси X
        self.rect.x += dx
        self.is_moving = (dx != 0) # Устанавливаем флаг движения

        if dx > 0 and not self.facing_right:
            self.facing_right = True
            # При смене направления можно сбросить индекс анимации
            self.current_frame_index = 0
            self.animation_counter = 0
        elif dx < 0 and self.facing_right:
            self.facing_right = False
            # При смене направления можно сбросить индекс анимации
            self.current_frame_index = 0
            self.animation_counter = 0

    def apply_gravity(self):
        # Добавляем гравитацию
        self.velocity_y += GRAVITY
        self.rect.y += self.velocity_y

        # Проверка, чтобы персонаж не ушёл ниже земли
        if self.rect.y >= GROUND_Y:
            self.rect.y = GROUND_Y
            self.velocity_y = 0
            if self.isJumping: # Если приземлились после прыжка
                self.isJumping = False
                self.set_animation_state("player_idle") # Или "player_walk" если сразу двигаемся
            self.is_falling = False
        elif self.velocity_y > 0 and not self.isJumping: # Если падаем, но не в результате прыжка
            self.is_falling = True
            self.isJumping = False # Убедимся, что isJumping False, если это падение

    def jump(self):
        # Прыжок
        if not self.isJumping and not self.is_falling: # Можем прыгать только если не прыгаем и не падаем
            self.velocity_y = JUMP_POWER
            self.isJumping = True
            self.set_animation_state("player_jump") # Активируем анимацию прыжка

    def update_animation(self):
        """Обновляет текущий кадр анимации на основе состояния персонажа."""
        # Выбираем правильный набор кадров (влево или вправо)
        current_animation_set = []
        if self.facing_right:
            current_animation_set = self.current_animation_set_right
        else:
            current_animation_set = self.current_animation_set_left

        if not current_animation_set: # Если нет кадров для текущей анимации
            return

        # Логика для выбора анимации
        if self.isJumping or self.is_falling:
            # Анимация прыжка/падения
            self.set_animation_state("player_jump") # Используем jump анимацию для прыжка и падения
            current_animation_set = self.animations_right["player_jump"] if self.facing_right else self.animations_left["player_jump"]
            # Для прыжка/падения часто используют один или несколько фиксированных кадров.
            # Здесь мы можем просто показать первый кадр прыжка или последний.
            # Если у вас несколько кадров прыжка, вы можете анимировать их так же, как ходьбу.
            if self.current_frame_index >= len(current_animation_set):
                self.current_frame_index = len(current_animation_set) - 1 # Остаемся на последнем кадре
            self.image = current_animation_set[self.current_frame_index]
        elif self.is_moving:
            # Анимация ходьбы
            if self.current_animation_set_right != self.animations_right["player_walk"]: # Избегаем постоянной переустановки
                self.set_animation_state("player_walk")
            
            current_animation_set = self.animations_right["player_walk"] if self.facing_right else self.animations_left["player_walk"]
            self.animation_counter += self.animation_speed
            if self.animation_counter >= len(current_animation_set):
                self.animation_counter = 0 # Зацикливаем анимацию
            self.current_frame_index = int(self.animation_counter)
            self.image = current_animation_set[self.current_frame_index]
        else:
            # Анимация стояния (idle)
            if self.current_animation_set_right != self.animations_right["player_idle"]: # Избегаем постоянной переустановки
                self.set_animation_state("player_idle")

            current_animation_set = self.animations_right["player_idle"] if self.facing_right else self.animations_left["player_idle"]
            self.animation_counter += self.animation_speed
            if self.animation_counter >= len(current_animation_set):
                self.animation_counter = 0 # Зацикливаем анимацию
            self.current_frame_index = int(self.animation_counter)
            self.image = current_animation_set[self.current_frame_index]

        # Обновляем изображение на основе выбранного кадра
        # Этот блок нужен, чтобы убедиться, что image всегда актуален
        if current_animation_set:
            self.image = current_animation_set[self.current_frame_index]
        else:
            self.image = pygame.Surface((self.rect.width, self.rect.height))
            self.image.fill((255, 0, 255)) # Заглушка

# Параметры игрока
player_x = 0
player_y = 330 # Начальная позиция игрока
player_forward = 0

# Создаем игрока
player = GameObject(player_x, player_y, 230, 230) # Указываем размеры персонажа

start = True
while start:
    # Рисуем текущий фон
    screen.blit(background, (0, 0))

    # Reset movement state at the beginning of each frame
    # player.is_moving = False # Это важно для корректного переключения idle/walk

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            start = False  # Выход из игры

        elif event.type == pygame.KEYDOWN:
            # Нажатие кнопок
            if event.key == pygame.K_d:
                player_forward = 5  # Движение вправо
            elif event.key == pygame.K_a:
                player_forward = -5  # Движение влево
            elif event.key == pygame.K_SPACE:
                player.jump()  # Прыжок

        elif event.type == pygame.KEYUP:
            if event.key in (pygame.K_d, pygame.K_a):
                player_forward = 0

    # Обновляем состояние персонажа
    player.apply_gravity()
    player.move(player_forward)
    player.update_animation() # Обновляем анимацию

    # Рисуем персонажа
    player.draw()

    pygame.display.flip()
    clock.tick(60) # Частота кадров
pygame.quit()
